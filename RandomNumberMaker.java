import java.util.Random;


public class RandomNumberMaker {
	
	//centralized Random Number Generator?
	private long startSeed;
	private Random rng;
	private double last;
	private int period = WorldState.streamNumber * 123456;
	private double next =  -1;
	
    /**
     * Default constructor to initialize the random number generator
	 *
     * @param sow the seed to start the random number generation
     */
	public RandomNumberMaker(long seed, int streamNumber)
	{	
		startSeed = seed;
		last = seed;
		
		for(int i = 0; i < streamNumber * period; i++)
		{//calculate a seed variant for the appropriate stream using an lcg function
			last = lcg(last);
		}
		//seed the random number generator with the generated seed
		rng = new Random((long) last);
	}//end constructor
	
	public RandomNumberMaker()
	{
		rng = new Random();
		last = rng.nextDouble();
	}
	
	public synchronized double lcg(double last)
	{//take the input number and find the next iteration of it
		return (Math.pow(7,5) * last) % (Math.pow(2,31) - 1);
	}
	
    /**
     * Generates a pseudo-random double
	 *
     * @return double returns a pseudo-random double number
     */
	public synchronized double rDouble()
	{//generates a pseudo-random double
		last = rng.nextDouble();
		return last;
	}

    /**
     * Returns the last generated double
	 *
     * @return double returns the last generated double
     */
	public synchronized double getLast()
	{//returns the last number generated by the RandomNumberGenerator
		//mainly for testing
		return last;
	}
	
    /**
     * Generates a pseudo-random int
	 *
     * @return int returns a pseudo-random int number
     */
	public synchronized int rInt()
	{//returns a random int from the maker
		int x = rng.nextInt();
		//last = (double) x;
		return x;
	}
	
	public synchronized int rInt(int bound)
	{
		int x = rng.nextInt(bound);
		return x;
	}
	
    /**
     * Generates a pseudo-random exponential variate
     * 
	 * @param lambda the lambda for the calculation
     * @return double returns a pseudo-random double exponential variate
     */
	public synchronized double eVariate(double lambda)
	{//returns an exponentialVariate
		double u = rDouble();
		double x = -(1/lambda) * Math.log(1-u);
		return x;
	}
	
    /**
     * Generates a pseudo-random poisson variate
     * 
	 * @param lambda the lambda for the calculation
     * @return double returns a pseudo-random double poisson variate
     */
	public synchronized double pVariate(double lambda)
	{//returns a poissonVariate		
		double y = 0;
		double L = Math.pow(Math.E, -lambda);
		double s = 1;
		double n = 0;
		
		//Knut's algorithm
		do 
		{
			y = eVariate(lambda);
			s *= y;
			n++;
		}while (s <= L);//end while
	
		return n-1; 
	}//end pVariate

	public synchronized double nVariate(double mu, double sigma)
	{	//returns a normally distributed random variate	
		if (next != -1)
		{
			double x = next;
			next = -1;
			return x;
		}
		
		double u1 = rDouble();
		double u2 = rDouble();
		double x = mu + (sigma * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2));
		next = mu + (sigma * Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2));
	
		return x;	
	}
}
